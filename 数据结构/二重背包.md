小安去超市购物，现在有面值1元，5元，10元，20元，50元，100元的零钱各若干张。超市结账移动需要M元，如果不用找零，可以有多少种组合来组成M元，返回各种组合的长度总和。

第一行包含6个整数，分别代表1、5、10、20、50、100每种面值的数目。
假设输入是`6 5 4 3 2 1`，则代表1元的有6张，5元的有5张，...100元的有1张。
第二行是一个整数，代表需要凑多少钱。

输出描述：
输出为一个整数，为各种组合的长度之和。

例如，输出的组合有三种，分别为`[1 1 1 1 1 1 5]`，`[1 5 5]`和`[1 10]`，那么组合长度分别为7、3、2，则其和为12。

注意：如果不存在这样的组合，请输出-1。


//作者：东东小朋友
//链接：https://www.nowcoder.com/discuss/219478?type=1

//dp[j]为当前组成j元的组合长度之和, cur[j]为组合数, 依次增加新的纸币,
//第i次循环增加价值为v[i]的纸币, 该纸币最多有c[i]张,
//加入后j元组合为原有j的组合以及 原有j - k * v[i] 组合加上k张v[i]的纸币得到的新组合,
//组合长度之和更新加上新组合的长度, 组合数则加上j - k * v[i] 组合数


```cpp
int main() {
    vector<int> c(6);
    vector<int> v{ 1, 5, 10, 20, 50, 100 };
    for (int i = 0; i < 6; i++) {
        cin >> c[i];
    }
    int n;
    cin >> n;
    vector<int> cur(n + 1, 0);
    vector<int> dp(n + 1, 0);
    dp[0] = 0;
    cur[0] = 1;
    for (int i = 0; i < 6; i++) {
        for (int j = n; j >= v[i]; j--) {
            for (int k = 1; k <= c[i] && j - k * v[i] >= 0; k++) {
                dp[j] += dp[j - k * v[i]] + k * cur[j - k * v[i]];
                cur[j] += cur[j - k * v[i]];
            }
        }
    }
    cout << dp[n] << endl;
}
```
